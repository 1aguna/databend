// Copyright 2021 Datafuse Labs.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::fs::File;
use std::io::Write;
use std::path::Path;

use common_datavalues::prelude::*;

pub fn write_arithmetic_result_type() {
    use DataType::*;
    use DataValueArithmeticOperator::*;

    let dest = Path::new("common/functions/src/scalars/arithmetics");
    let path = dest.join("result_type.rs");

    let mut file = File::create(&path).expect("open");
    // Write the head.
    writeln!(
        file,
        "// Copyright 2021 Datafuse Labs.
//
// Licensed under the Apache License, Version 2.0 (the \"License\");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an \"AS IS\" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This code is generated by common/codegen. DO NOT EDIT.
use common_datavalues::DFPrimitiveType;

pub trait ResultTypeOfBinaryArith {{
    type AddMul: DFPrimitiveType;
    type Minus: DFPrimitiveType;
    type IntDiv: DFPrimitiveType;
    type Modulo: DFPrimitiveType;
}}

pub trait ResultTypeOfUnaryArith {{
    type Negate: DFPrimitiveType;
}}"
    )
    .unwrap();

    let lhs = vec![
        UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, Float32, Float64,
    ];
    let rhs = lhs.clone();
    for left in &lhs {
        for right in &rhs {
            let add_mul = numerical_arithmetic_coercion(&Plus, left, right).unwrap();
            let minus = numerical_arithmetic_coercion(&Minus, left, right).unwrap();
            let int_div = numerical_arithmetic_coercion(&IntDiv, left, right).unwrap();
            let modulo = numerical_arithmetic_coercion(&Modulo, left, right).unwrap();
            writeln!(
                file,
                "
impl ResultTypeOfBinaryArith for ({}, {}) {{
    type AddMul = {};
    type Minus = {};
    type IntDiv = {};
    type Modulo = {};
}}",
                to_primitive_str(left),
                to_primitive_str(right),
                to_primitive_str(&add_mul),
                to_primitive_str(&minus),
                to_primitive_str(&int_div),
                to_primitive_str(&modulo),
            )
            .unwrap();
        }
    }

    for arg in &lhs {
        let negate = numerical_unary_arithmetic_coercion(&Minus, arg).unwrap();
        writeln!(
            file,
            "
impl ResultTypeOfUnaryArith for {} {{
    type Negate = {};
}}",
            to_primitive_str(arg),
            to_primitive_str(&negate),
        )
        .unwrap();
    }
    file.flush().unwrap();
}

fn to_primitive_str(dt: &DataType) -> &str {
    use DataType::*;
    match dt {
        UInt8 => "u8",
        UInt16 => "u16",
        UInt32 => "u32",
        UInt64 => "u64",
        Int8 => "i8",
        Int16 => "i16",
        Int32 => "i32",
        Int64 => "i64",
        Float32 => "f32",
        Float64 => "f64",
        _ => panic!("unsupported data type"),
    }
}
